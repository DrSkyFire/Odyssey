# LED指示灯说明文档（诊断版）

## 📌 当前LED定义（诊断模式）

**最新修改时间：2025-11-02**

为了诊断测量异常问题，LED分配已临时修改为诊断模式：

| LED位置 | 信号名称 | 含义 | 正常状态 | 诊断要点 |
|---------|----------|------|----------|----------|
| **LED[0]** | `run_flag` | 系统运行状态 | ✅ 亮 = 运行中 | 必须亮 |
| **LED[1]** | `ch1_spectrum_active` | **FFT输出检测（锁存）** | ✅ 亮 = FFT有输出 | **关键诊断信号！** |
| **LED[2]** | `fft_start` | **FFT启动信号** | ✅ 亮 = FFT已启动 | **关键诊断信号！** |
| **LED[3]** | `work_mode[0]` | 工作模式 bit0 | 1 = 频域/测量模式 | 配合LED[4]判断 |
| **LED[4]** | `work_mode[1]` | 工作模式 bit1 | 0 = 频域模式 | 配合LED[3]判断 |
| **LED[5]** | `test_mode` | 测试信号模式 | ❌ 灭 = 实际信号 | 必须灭 |
| **LED[6]** | `pll1_lock` | PLL1锁定状态 | ✅ 亮 = 时钟正常 | 必须亮 |
| **LED[7]** | `pll2_lock` | PLL2锁定状态 | ✅ 亮 = HDMI时钟正常 | 必须亮 |

---

## 🎯 工作模式编码（LED[4][3]）

| LED[4] | LED[3] | work_mode | 模式名称 | FFT状态 |
|--------|--------|-----------|----------|---------|
| 0 | 0 | 2'b00 | 时域模式（示波器） | ❌ 禁用 |
| 0 | 1 | 2'b01 | **频域模式（FFT）** | ✅ **启用** |
| 1 | 0 | 2'b10 | 参数测量模式 | ❌ 禁用 |
| 1 | 1 | 2'b11 | （保留） | - |

**期望状态**：LED[4]=0（灭），LED[3]=1（亮） → 频域模式

---

## 🔍 诊断步骤

### 请观察你的LED灯状态并回答：

#### 1️⃣ 基础状态检查
- **LED[0] (运行状态)**: □ 亮 □ 灭
- **LED[6] (PLL1锁定)**: □ 亮 □ 灭
- **LED[7] (PLL2锁定)**: □ 亮 □ 灭

如果 LED[0] 亮 且 LED[6][7] 都亮 → 系统运行正常

#### 2️⃣ 信号状态检查
- **LED[1] (CH1溢出)**: □ 亮 □ 灭 → 如果亮，说明信号幅度 > 3.3V
- **LED[2] (CH2溢出)**: □ 亮 □ 灭
- **LED[5] (测试模式)**: □ 亮 □ 灭 → **如果亮，系统使用内部测试信号！**

#### 3️⃣ 通道状态检查
- **LED[3] (FFT通道)**: □ 亮 □ 灭 → 如果闪烁，说明FFT在双通道切换
- **LED[4] (显示通道)**: □ 亮 □ 灭

---

## 🚨 **最可能的问题原因**

根据你的测试数据分析，有两个可能性：

### 可能性1：测试模式被意外启用（90%概率）
**症状**:
- ✅ HDMI显示频谱图（说明work_mode=1正确）
- ❌ 测量数据完全错误
- ❌ THD恒为0%

**检查方法**:
```
观察 LED[5] (test_mode):
- 如果 LED[5] 亮 → 系统在使用内部1kHz测试信号，不是你的信号发生器！
- 如果 LED[5] 灭 → 系统在测量实际输入信号
```

**原因**: 
代码中测试模式可能在某个历史版本中被启用，导致系统忽略ADC输入，使用内部查表生成的1kHz正弦波。

**解决方法**:
- 按 `user_button[7]` 切换测试模式
- 或者修改代码强制 `test_mode = 0`

---

### 可能性2：work_mode 在编译时被覆盖（10%概率）
虽然代码设置了 `work_mode <= 2'd1`，但可能在综合/布局布线时被优化或覆盖。

**验证方法**:
需要查看综合报告或使用逻辑分析仪抓取 `work_mode` 信号。

---

## 🛠️ 立即修复方案

### 方案A：添加工作模式LED指示（推荐）

修改 LED 分配，把不太重要的 `current_fft_channel` 或 `display_channel` 替换为 `work_mode` 指示：

```verilog
user_led_reg[0] <= run_flag;                  // 运行状态
user_led_reg[1] <= adc_ch1_otr_sync_100m;     // 通道1溢出
user_led_reg[2] <= adc_ch2_otr_sync_100m;     // 通道2溢出
user_led_reg[3] <= work_mode[0];              // 工作模式 bit0
user_led_reg[4] <= work_mode[1];              // 工作模式 bit1
                                              // 00=时域 01=频域 10=测量
user_led_reg[5] <= test_mode;                 // 测试模式
user_led_reg[6] <= pll1_lock;                 // PLL1锁定
user_led_reg[7] <= pll2_lock;                 // PLL2锁定
```

工作模式编码：
- `LED[4]=0, LED[3]=0` → 时域模式
- `LED[4]=0, LED[3]=1` → **频域模式（FFT）** ← 应该是这个状态
- `LED[4]=1, LED[3]=0` → 参数测量模式

---

### 方案B：强制禁用测试模式（临时方案）

在代码中强制设置：

```verilog
// Line 1775附近，添加：
work_mode <= 2'd1;   // ✓ 默认频域模式
test_mode <= 1'b0;   // ✓ 强制禁用测试模式
```

---

## 📋 下一步行动

### 立即检查（5分钟）

1. **观察 LED[5]** (test_mode):
   - 如果亮 → 按 button[7] 关闭测试模式
   - 重新测试 1kHz 信号，频率应该正常

2. **观察 LED[0][6][7]**:
   - 确认系统运行且时钟正常

3. **观察 LED[1][2]**:
   - 如果亮 → 降低信号发生器幅度

### 如果LED[5]是灭的（测试模式未启用）

则需要：
1. 添加 work_mode LED指示（方案A）
2. 重新编译下载
3. 确认 LED[3][4] 显示 `01`（频域模式）

---

## 🎯 测试清单

- [ ] LED[0] 运行状态 = 亮
- [ ] LED[6] PLL1锁定 = 亮
- [ ] LED[7] PLL2锁定 = 亮
- [ ] LED[5] 测试模式 = **灭**（关键！）
- [ ] LED[1][2] ADC溢出 = 灭
- [ ] HDMI 显示频谱图
- [ ] 重新测试 1kHz 正弦波

---

**请先告诉我 LED[5] 的状态！这是最关键的诊断信息！**
