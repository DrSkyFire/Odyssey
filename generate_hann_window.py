#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Hann窗系数生成器
生成8192点Hann窗系数，用于FFT频谱分析
输出格式：16位定点数 (Q15格式)
"""

import numpy as np
import os

def generate_hann_window(N=8192, output_dir='ipcore/hann_window'):
    """
    生成Hann窗系数
    
    参数:
        N: 窗长度 (8192点)
        output_dir: 输出目录
    
    输出文件:
        hann_window_8192.coe - Xilinx COE格式
        hann_window_8192.mif - Altera MIF格式
        hann_window_8192.hex - 通用HEX格式
    """
    
    # 创建输出目录
    os.makedirs(output_dir, exist_ok=True)
    
    # 生成Hann窗
    # w(n) = 0.5 - 0.5 * cos(2*pi*n/(N-1)), n = 0, 1, ..., N-1
    n = np.arange(N)
    window = 0.5 - 0.5 * np.cos(2 * np.pi * n / (N - 1))
    
    # 量化到16位定点数 (Q15格式)
    # Q15: 1个符号位 + 15位小数位
    # 范围: -1.0 ~ +0.999969482421875
    # 对于Hann窗，值域是[0, 1]，所以直接乘以32767
    window_q15 = np.round(window * 32767).astype(np.int16)
    
    # 转换为16位无符号数（FPGA ROM输出通常是无符号）
    window_uint16 = window_q15.astype(np.uint16)
    
    # 统计信息
    print(f"Hann窗生成统计:")
    print(f"  窗长度: {N}")
    print(f"  最小值: {window.min():.6f} (原始) -> {window_q15.min()} (Q15)")
    print(f"  最大值: {window.max():.6f} (原始) -> {window_q15.max()} (Q15)")
    print(f"  中心值: {window[N//2]:.6f} (原始) -> {window_q15[N//2]} (Q15)")
    print(f"  首尾值: {window[0]:.6f} (原始) -> {window_q15[0]} (Q15)")
    
    # 生成Xilinx COE格式 (用于Block Memory Generator)
    coe_file = os.path.join(output_dir, 'hann_window_8192.coe')
    with open(coe_file, 'w') as f:
        f.write("; Hann Window Coefficients - 8192 points\n")
        f.write("; Generated by generate_hann_window.py\n")
        f.write("; Format: 16-bit unsigned Q15 (0x0000 - 0x7FFF)\n")
        f.write("; Window formula: w(n) = 0.5 - 0.5*cos(2*pi*n/(N-1))\n")
        f.write(";\n")
        f.write("memory_initialization_radix=16;\n")
        f.write("memory_initialization_vector=\n")
        for i, val in enumerate(window_uint16):
            if i == len(window_uint16) - 1:
                f.write(f"{val:04X};")  # 最后一个以分号结尾
            else:
                f.write(f"{val:04X},")
                if (i + 1) % 16 == 0:
                    f.write("\n")  # 每16个值换行
        f.write("\n")
    print(f"\n生成Xilinx COE格式: {coe_file}")
    
    # 生成Altera MIF格式 (用于Gowin FPGA)
    mif_file = os.path.join(output_dir, 'hann_window_8192.mif')
    with open(mif_file, 'w') as f:
        f.write("-- Hann Window Coefficients - 8192 points\n")
        f.write("-- Generated by generate_hann_window.py\n")
        f.write("-- Format: 16-bit unsigned Q15 (0x0000 - 0x7FFF)\n")
        f.write("-- Window formula: w(n) = 0.5 - 0.5*cos(2*pi*n/(N-1))\n")
        f.write("\n")
        f.write("WIDTH=16;\n")
        f.write("DEPTH=8192;\n")
        f.write("ADDRESS_RADIX=DEC;\n")
        f.write("DATA_RADIX=HEX;\n")
        f.write("\n")
        f.write("CONTENT BEGIN\n")
        for i, val in enumerate(window_uint16):
            f.write(f"    {i:5d} : {val:04X};\n")
        f.write("END;\n")
    print(f"生成Altera MIF格式: {mif_file}")
    
    # 生成通用HEX格式（每行一个值，用于Verilog $readmemh）
    hex_file = os.path.join(output_dir, 'hann_window_8192.hex')
    with open(hex_file, 'w') as f:
        for val in window_uint16:
            f.write(f"{val:04X}\n")
    print(f"生成通用HEX格式: {hex_file}")
    
    # 生成Verilog参数定义文件（用于小型查找表实现）
    # 由于8192点太大，这里生成对称索引版本的说明
    vh_file = os.path.join(output_dir, 'hann_window_info.vh')
    with open(vh_file, 'w') as f:
        f.write("// Hann窗ROM使用说明\n")
        f.write("// 由于Hann窗对称性，可以只存储前4096个值\n")
        f.write("// 读取时: addr >= 4096 ? window[8191-addr] : window[addr]\n")
        f.write("\n")
        f.write(f"// 窗长度: {N}\n")
        f.write(f"// 数据位宽: 16位 (Q15定点数)\n")
        f.write(f"// 地址位宽: 13位 (0-8191)\n")
        f.write("\n")
        f.write("// ROM初始化文件:\n")
        f.write("// - hann_window_8192.coe (Xilinx)\n")
        f.write("// - hann_window_8192.mif (Altera/Gowin)\n")
        f.write("// - hann_window_8192.hex (Verilog $readmemh)\n")
        f.write("\n")
        f.write("// 使用示例 (Verilog):\n")
        f.write("//   reg [15:0] window_rom [0:8191];\n")
        f.write("//   initial $readmemh(\"hann_window_8192.hex\", window_rom);\n")
        f.write("//   wire [15:0] window_coeff = window_rom[addr];\n")
        f.write("\n")
        f.write("// 乘法使用:\n")
        f.write("//   // ADC数据是11位有符号数，扩展到16位\n")
        f.write("//   wire signed [15:0] adc_signed = {{5{adc_data[10]}}, adc_data};\n")
        f.write("//   // Hann窗系数是16位无符号数 (Q15)\n")
        f.write("//   wire [15:0] window_coeff;\n")
        f.write("//   // 乘法结果是32位，取高16位（去掉Q15的15位小数）\n")
        f.write("//   wire signed [31:0] mult_result = adc_signed * $signed({1'b0, window_coeff});\n")
        f.write("//   wire signed [15:0] windowed_data = mult_result[30:15];  // 取[30:15]保留符号\n")
    print(f"生成Verilog说明文件: {vh_file}")
    
    # 生成Python验证文件
    py_file = os.path.join(output_dir, 'verify_hann_window.py')
    with open(py_file, 'w') as f:
        f.write("#!/usr/bin/env python3\n")
        f.write("# -*- coding: utf-8 -*-\n")
        f.write('"""\n')
        f.write("Hann窗系数验证脚本\n")
        f.write("读取生成的HEX文件并绘制窗函数曲线\n")
        f.write('"""\n\n')
        f.write("import numpy as np\n")
        f.write("import matplotlib.pyplot as plt\n\n")
        f.write("# 读取HEX文件\n")
        f.write("window_q15 = []\n")
        f.write("with open('hann_window_8192.hex', 'r') as f:\n")
        f.write("    for line in f:\n")
        f.write("        val = int(line.strip(), 16)\n")
        f.write("        window_q15.append(val)\n\n")
        f.write("# 转换回浮点数\n")
        f.write("window = np.array(window_q15, dtype=np.float64) / 32767.0\n\n")
        f.write("# 绘图\n")
        f.write("plt.figure(figsize=(12, 6))\n")
        f.write("plt.subplot(2, 1, 1)\n")
        f.write("plt.plot(window)\n")
        f.write("plt.title('Hann Window - 8192 points')\n")
        f.write("plt.xlabel('Sample')\n")
        f.write("plt.ylabel('Amplitude')\n")
        f.write("plt.grid(True)\n\n")
        f.write("# FFT分析（显示频域特性）\n")
        f.write("plt.subplot(2, 1, 2)\n")
        f.write("window_fft = np.fft.fft(window, 16384)\n")
        f.write("window_fft_db = 20 * np.log10(np.abs(window_fft[:8192]) + 1e-10)\n")
        f.write("plt.plot(window_fft_db)\n")
        f.write("plt.title('Hann Window - Frequency Response')\n")
        f.write("plt.xlabel('Frequency Bin')\n")
        f.write("plt.ylabel('Magnitude (dB)')\n")
        f.write("plt.grid(True)\n")
        f.write("plt.ylim([-100, 20])\n\n")
        f.write("plt.tight_layout()\n")
        f.write("plt.savefig('hann_window_plot.png', dpi=150)\n")
        f.write("print('Verification plot saved: hann_window_plot.png')\n")
        f.write("plt.show()\n")
    print(f"生成验证脚本: {py_file}")
    
    print(f"\n✓ Hann窗系数生成完成！")
    print(f"  输出目录: {output_dir}")
    print(f"  文件数量: 5个")
    print(f"\n下一步：在Gowin FPGA中使用MIF文件初始化Block RAM")

if __name__ == '__main__':
    generate_hann_window()
