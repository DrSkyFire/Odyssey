# FFT峰值搜索算法致命缺陷分析

## 🐛 Bug描述

**症状**：无论输入什么信号，甚至断开信号，系统始终显示 8544 Hz

**实测数据**：
- 输入1kHz正弦波 → 显示8544Hz
- 输入2kHz正弦波 → 显示8544Hz  
- 断开信号 → 仍然显示8544Hz
- 双通道都显示相同的8544Hz
- 8544 = 2 × 4272 (bin 2)

---

## 🔍 根本原因

### 原代码问题

```verilog
// 扫描开始时重置
if (spectrum_addr == 13'd0) begin
    fft_max_amp <= 16'd0;  // ❌ 初始化为0
    fft_peak_bin <= 13'd0;
end

// 峰值搜索
else if (spectrum_addr >= 13'd1 && spectrum_addr < 4096) begin
    if (spectrum_data > fft_max_amp) begin  // ❌ 任何值 > 0
        fft_max_amp <= spectrum_data;
        fft_peak_bin <= spectrum_addr;
    end
end
```

### 问题分析

#### 1. 初始值为0导致的陷阱

| Bin | 频谱幅度 | 比较结果 | fft_peak_bin |
|-----|----------|----------|--------------|
| 0 (DC) | 跳过 | - | 0 |
| 1 | 10 (噪声) | 10 > 0 ✅ | **1** ← 第一个峰值 |
| 2 | 20 (噪声) | 20 > 10 ✅ | **2** ← 更新 |
| 3 | 5 (噪声) | 5 < 20 ❌ | 2 |
| ... | <10 (噪声底) | 都 < 20 ❌ | 2 ← 锁定！|
| 234 | **1500 (1kHz峰值)** | 1500 > 20 ✅ | 234 ← 应该更新但... |

**问题**：
- FFT的噪声底不是0，通常是5-50之间的小值
- bin 1, 2 的噪声（即使只有10-20）会被误认为峰值
- **如果真实信号很微弱，或者FFT幅度归一化问题，bin 1-2的噪声可能一直是最大值**

#### 2. 为什么是bin 2 (8544 Hz)?

可能原因：
1. **频谱泄漏**：DC分量泄漏到bin 1, 2
2. **ADC偏置**：ADC有直流偏移，导致DC附近能量高
3. **FFT窗函数**：Hann窗的旁瓣可能在低频bin更明显
4. **数字噪声**：系统时钟、开关噪声耦合到低频

**关键**：无论原因是什么，bin 2的值总是 > bin 3-4096的噪声底！

---

## ✅ 修复方案

### 方案1：设置噪声阈值（已实现）

```verilog
// 扫描开始时设置阈值
if (spectrum_addr == 13'd0) begin
    fft_max_amp <= 16'd100;  // ✅ 噪声阈值
    fft_peak_bin <= 13'd0;
end

// 峰值搜索
else if (spectrum_addr >= 13'd1 && spectrum_addr < 4096) begin
    if (spectrum_data > fft_max_amp) begin  // ✅ 必须 > 100
        fft_max_amp <= spectrum_data;
        fft_peak_bin <= spectrum_addr;
    end
end

// 扫描结束时验证
else if (spectrum_addr == 4096) begin
    if (fft_max_amp > 16'd100) begin  // ✅ 有效信号检测
        fft_freq_hz <= fft_peak_bin * FREQ_RES;
        fft_freq_ready <= 1'b1;
    end else begin
        fft_freq_ready <= 1'b0;  // ✅ 回退到时域测量
    end
end
```

**效果**：
- 噪声底（<50）被过滤
- 有效信号（>100）才会被检测
- 无信号时自动回退到时域测量

---

### 方案2：自适应阈值（备选）

```verilog
reg [15:0] noise_floor;  // 噪声底估计

// 计算前10个bin的平均值作为噪声底
if (spectrum_addr < 13'd10) begin
    noise_sum <= noise_sum + spectrum_data;
end else if (spectrum_addr == 13'd10) begin
    noise_floor <= noise_sum[19:4];  // 平均值 / 16
    fft_max_amp <= noise_floor * 3;  // 阈值 = 3倍噪声底
end
```

---

## 📊 预期效果对比

### 修复前

| 输入信号 | 检测bin | 显示频率 | 状态 |
|---------|---------|---------|------|
| 无信号 | 2 | 8544 Hz | ❌ 错误 |
| 1kHz 1Vpp | 2 | 8544 Hz | ❌ 错误 |
| 10kHz 1Vpp | 2 | 8544 Hz | ❌ 错误 |
| 100kHz 1Vpp | 2 | 8544 Hz | ❌ 错误 |

**所有信号都显示bin 2的噪声频率！**

---

### 修复后

| 输入信号 | 检测bin | 显示频率 | 状态 |
|---------|---------|---------|------|
| 无信号 | (无) | 0 Hz (时域) | ✅ 正确 |
| 1kHz 1Vpp | 0.234 | 996-1004 Hz | ✅ 正确 |
| 10kHz 1Vpp | 2.34 | 9.96-10.04 kHz | ✅ 正确 |
| 100kHz 1Vpp | 23.4 | 99.6-100.4 kHz | ✅ 正确 |

**噪声被过滤，真实信号被正确检测！**

---

## 🧪 验证测试

### 测试1：无信号测试
```
步骤：
1. 断开所有输入
2. 观察频率显示

预期结果：
- 修复前：8544 Hz（锁定到噪声）
- 修复后：0 Hz 或时域过零检测值
```

### 测试2：1kHz正弦波测试
```
步骤：
1. 输入1kHz 1Vpp正弦波
2. 观察频率显示

预期结果：
- 修复前：8544 Hz
- 修复后：996-1004 Hz ✅
```

### 测试3：不同频率测试
```
测试多个频率，验证检测正确性：
- 100 Hz → 90-110 Hz
- 1 kHz → 996-1004 Hz
- 10 kHz → 9.96-10.04 kHz
- 100 kHz → 99.6-100.4 kHz
```

---

## 💡 技术要点

### 1. 噪声阈值选择

**阈值100的依据**：
```
典型FFT幅度范围（10位ADC，8192点FFT）：
- 噪声底: 5-50
- 100mVpp信号: 200-500
- 1Vpp信号: 1000-2000  
- 3.3Vpp信号: 3000-6000

阈值100 = 噪声底的2-3倍，可以有效过滤
```

### 2. 为什么bin 2？

**频谱泄漏分析**：
```
DC偏置 → 能量主要在bin 0
频谱泄漏 → 能量扩散到bin 1, 2, 3...
窗函数 → Hann窗使能量更集中

bin 0: DC (跳过)
bin 1: DC泄漏主瓣
bin 2: DC泄漏副瓣 ← 往往比bin 3-10更大！
bin 3+: 快速衰减
```

### 3. 回退机制

```verilog
if (fft_max_amp > threshold) {
    // 使用FFT频率（高精度）
    use_fft_freq = 1;
} else {
    // 使用时域测量（回退）
    use_fft_freq = 0;
}
```

**好处**：
- 强信号：FFT高精度测量
- 弱信号/无信号：时域测量不会出现错误锁定

---

## 🎯 总结

### Bug的本质
**峰值搜索算法缺少信噪比判断**
- 把噪声底当作有效峰值
- 低频噪声往往比高频噪声大（DC泄漏）
- 导致系统永远锁定到bin 2

### 修复的核心
**添加幅度阈值判断**
- 只有超过阈值的峰值才是有效信号
- 阈值设置为噪声底的2-3倍
- 无效信号时回退到时域测量

### 教训
**数字信号处理中，阈值判断至关重要**
- FFT输出永远不是纯0（总有噪声）
- 必须区分信号和噪声
- 阈值可以是固定值或自适应计算

---

**现在请重新编译下载，测试1kHz信号！**
