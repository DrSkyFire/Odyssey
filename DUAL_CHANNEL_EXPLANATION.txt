=============================================================================
 双通道工作机制详解
=============================================================================
文档版本: v1.0
更新日期: 2025-10-24
适用系统: FPGA信号分析仪 Odyssey项目

=============================================================================
 核心概念
=============================================================================

本系统采用 **双通道同步采集** 架构，关键要点：

1. ✅ CH1和CH2 **始终同步采集**，无论任何模式
2. ✅ 两个通道 **完全独立** 的ADC和FIFO
3. ✅ Button[3]选择 **触发源**（哪个通道判断触发条件）
4. ✅ Button[6]选择 **显示源**（屏幕显示哪个通道）
5. ✅ 触发时 **两个通道同时捕获** 数据

=============================================================================
 数据流架构图
=============================================================================

【完整数据路径】

              ┌─────────────────────────────────────────────┐
              │         物理硬件层 (同步采集)               │
              └─────────────────────────────────────────────┘
                              ▲         ▲
                              │         │
                          1MHz ADC  1MHz ADC
                              │         │
                              │         │
    信号输入 ────> CH1 ───────┴─────────┴───────> CH2 <──── 信号输入
    (0-3.3V)       (绿)                            (红)     (0-3.3V)
                    │                                │
                    │                                │
                    ▼                                ▼
              ┌──────────┐                    ┌──────────┐
              │  FIFO1   │                    │  FIFO2   │
              │ 2048深度 │                    │ 2048深度 │
              └──────────┘                    └──────────┘
                    │                                │
                    │                                │
                    └────────────┬───────────────────┘
                                 │
                                 ▼
              ┌─────────────────────────────────────┐
              │    双通道FFT控制器 (时分复用)       │
              │  • 先处理CH1 (1024点)               │
              │  • 再处理CH2 (1024点)               │
              │  • current_fft_channel切换          │
              └─────────────────────────────────────┘
                                 │
                                 ▼
              ┌─────────────────────────────────────┐
              │       FFT IP核 (1024点)             │
              │  • Pipeline流水线架构                │
              │  • 输出幅度谱和相位谱                │
              └─────────────────────────────────────┘
                                 │
                    ┌────────────┴────────────┐
                    │                         │
                    ▼                         ▼
              频谱数据CH1                 频谱数据CH2
                    │                         │
                    │                         │
                    └────────────┬────────────┘
                                 │
                                 ▼
              ┌─────────────────────────────────────┐
              │    HDMI显示控制器                   │
              │  • display_channel选择显示源        │
              │  • 时域: 显示对应FIFO数据           │
              │  • 频域: 显示对应频谱数据           │
              └─────────────────────────────────────┘
                                 │
                                 ▼
                            HDMI输出
                         (1920x1080@60Hz)

=============================================================================
 触发机制详解
=============================================================================

【触发源选择 - Button[3] 控制 channel_sel】

时域模式下的触发判断逻辑：

┌─────────────────────────────────────────────────────────────┐
│ if (channel_sel == 0):  // CH1作为触发源                    │
│     trigger_event = (ch1_data_d2 < trigger_level) &&        │
│                     (ch1_data_d1 >= trigger_level)          │
│ else:                   // CH2作为触发源                    │
│     trigger_event = (ch2_data_d2 < trigger_level) &&        │
│                     (ch2_data_d1 >= trigger_level)          │
└─────────────────────────────────────────────────────────────┘

触发发生后：
1. triggered标志置1
2. FIFO写使能激活
3. **两个FIFO同时写入** (ch1_fifo_wr_en=1, ch2_fifo_wr_en=1)
4. 写满1024点后，triggered清零

【关键代码逻辑】

// 信号选择（用于触发检测）
assign adc_data_sync = channel_sel ? ch2_data_sync[9:2] : ch1_data_sync[9:2];

// 边沿检测（单一触发源）
always @(posedge clk_adc) begin
    adc_data_d1 <= adc_data_sync;  // 选中通道的延迟1
    adc_data_d2 <= adc_data_d1;    // 选中通道的延迟2
end

assign trigger_event = (adc_data_d2 < trigger_level_sync) && 
                       (adc_data_d1 >= trigger_level_sync);

// FIFO写入（双通道同步）
assign ch1_fifo_wr_en = (work_mode == 0) ? 
                        (dual_data_valid && run_flag && triggered) :
                        (dual_data_valid && run_flag);

assign ch2_fifo_wr_en = (work_mode == 0) ? 
                        (dual_data_valid && run_flag && triggered) :
                        (dual_data_valid && run_flag);

=============================================================================
 显示源选择机制
=============================================================================

【显示通道 - Button[6] 控制 display_channel】

所有工作模式下都生效：

┌──────────────┬────────────────────┬────────────────────┐
│ 模式         │ display_channel=0  │ display_channel=1  │
├──────────────┼────────────────────┼────────────────────┤
│ 时域 (T)     │ 绿色波形 (CH1)     │ 红色波形 (CH2)     │
│              │ 从FIFO1读取时域数据 │ 从FIFO2读取时域数据 │
├──────────────┼────────────────────┼────────────────────┤
│ 频域 (F)     │ CH1频谱柱状图      │ CH2频谱柱状图      │
│              │ 显示spectrum_ch1   │ 显示spectrum_ch2   │
├──────────────┼────────────────────┼────────────────────┤
│ 测量 (M)     │ CH1参数数字        │ CH2参数数字        │
│              │ Freq/Amp/Duty/THD  │ Freq/Amp/Duty/THD  │
│              │ (基于CH1 FFT结果)  │ (基于CH2 FFT结果)  │
└──────────────┴────────────────────┴────────────────────┘

【HDMI顶部指示】

display_channel = 0:
┌────────────────────────────────────────┐
│ [CH1 绿色高亮] [CH2 暗灰色]            │  ← 当前显示CH1
└────────────────────────────────────────┘

display_channel = 1:
┌────────────────────────────────────────┐
│ [CH1 暗灰色] [CH2 红色高亮]            │  ← 当前显示CH2
└────────────────────────────────────────┘

【显示控制代码逻辑】

hdmi_display_ctrl.v 中的实现：

// 顶部通道指示
if (pixel_y < 30) begin  // 标题栏区域
    if (pixel_x < 100)
        rgb_data = current_channel ? 24'h404040 : 24'h00FF00;  // CH1
    else if (pixel_x < 200)
        rgb_data = current_channel ? 24'hFF0000 : 24'h404040;  // CH2
end

// 时域波形显示（简化逻辑）
if (work_mode == 0) begin  // 时域模式
    waveform_data = current_channel ? fifo2_data : fifo1_data;
    rgb_data = current_channel ? 24'hFF0000 : 24'h00FF00;
end

=============================================================================
 典型应用组合
=============================================================================

【组合1: 最常用配置】
┌──────────────────────────────────────────┐
│ channel_sel = 0      (CH1触发)           │
│ display_channel = 0  (显示CH1)           │
└──────────────────────────────────────────┘
效果: CH1作为触发源，屏幕显示CH1波形
用途: 单通道基本示波器功能

---

【组合2: 观察响应信号】
┌──────────────────────────────────────────┐
│ channel_sel = 0      (CH1触发)           │
│ display_channel = 1  (显示CH2)           │
└──────────────────────────────────────────┘
效果: CH1触发，屏幕显示CH2波形（与CH1同步）
用途: 
  • CH1连接稳定时钟/触发信号
  • CH2连接待测信号
  • 观察CH2在CH1触发时刻的状态
应用实例:
  • CH1=方波时钟，CH2=数据线 → 观察数据建立时间
  • CH1=门控信号，CH2=输出 → 观察门控响应

---

【组合3: 反向观察】
┌──────────────────────────────────────────┐
│ channel_sel = 1      (CH2触发)           │
│ display_channel = 0  (显示CH1)           │
└──────────────────────────────────────────┘
效果: CH2触发，屏幕显示CH1波形
用途: 用CH2的事件来捕获CH1的状态
应用实例:
  • CH2=中断信号，CH1=系统时钟 → 观察中断时的时钟状态
  • CH2=故障指示，CH1=电源 → 捕获故障瞬间电源波形

---

【组合4: 双通道切换对比】
┌──────────────────────────────────────────┐
│ channel_sel = 0      (CH1触发，固定)     │
│ display_channel = 0/1 (按[6]切换)       │
└──────────────────────────────────────────┘
效果: 固定触发源，快速切换显示
用途: 对比两路信号的波形差异
操作:
  1. 设置CH1触发，调整trigger_level到合适值
  2. 连续按Button[6]在CH1/CH2显示间切换
  3. 观察两个波形的幅度、形状、相位差异

=============================================================================
 时序示例
=============================================================================

【示例: channel_sel=0, 双通道同步捕获过程】

时间轴 (μs)    CH1信号         CH2信号         系统状态
─────────────────────────────────────────────────────────────
0              ▁▁▁ 0.5V        ▁▁▁ 1.0V        等待触发
                                                adc_data_d2 < level
                                                
1              ▂▂▂ 1.0V        ▂▂▂ 1.5V        采样延迟
                                                adc_data_d1存储
                                                
2              ▃▃▃ 1.8V        ▃▃▃ 2.0V        触发检测
               (trigger_level = 1.6V)           d2=1.0V, d1=1.8V
                                                触发条件满足！
                                                
3              ▄▄▄ 2.3V        ▄▄▄ 2.3V        triggered = 1
                ↑ 上升沿                        FIFO写入开始
                触发点                           ch1_fifo_wr_en = 1
                                                ch2_fifo_wr_en = 1
                                                
4-1027         继续采样...     继续采样...     同步写入1024点
                                                write_count++
                                                
1028           采样完成        采样完成        triggered = 0
                                                回到IDLE状态
                                                等待下一次触发

【关键观察点】
1. 触发判断只看CH1信号（因为channel_sel=0）
2. 触发发生时，**两个FIFO同时开始写入**
3. CH2数据同步捕获，虽然它不参与触发判断
4. 最终两个FIFO都有完整的1024点数据

=============================================================================
 常见误解澄清
=============================================================================

❌ 误解1: "按Button[3]选择采集哪个通道"
✅ 正确: 两个通道始终同时采集，Button[3]只选择触发源

❌ 误解2: "只有显示的通道在工作"
✅ 正确: 两个通道的ADC、FIFO、FFT都在工作，只是显示一个

❌ 误解3: "channel_sel=0时，CH2不会被采集"
✅ 正确: CH2照常采集和存储，只是不参与触发判断

❌ 误解4: "display_channel影响触发"
✅ 正确: display_channel只影响显示，与触发无关

❌ 误解5: "频域模式下Button[3]无用"
✅ 正确: 频域模式无触发概念，Button[3]确实无效果

=============================================================================
 调试技巧
=============================================================================

【技巧1: 快速切换观察】
在时域模式下，固定触发配置，只用Button[6]切换显示：
→ 可快速对比两路波形，无需重新调节触发

【技巧2: 用稳定信号做触发源】
如果CH1是稳定的正弦波，CH2是不稳定的信号：
→ 设置channel_sel=0，display_channel=1
→ 用稳定的CH1触发，观察CH2的不稳定波形

【技巧3: 互为触发对比】
测试两路信号谁更稳定：
→ 先设channel_sel=0，观察波形稳定性
→ 再设channel_sel=1，对比稳定性差异
→ 稳定性更好的作为最终触发源

【技巧4: 频域双通道对比】
比较两路信号的频谱差异：
1. 切换到频域模式（Mode:F）
2. display_channel=0，记录CH1频谱特征
3. 按Button[6]切换，对比CH2频谱
4. 找出频谱差异点（谐波、噪声等）

【技巧5: 测量模式看相位差】
快速测量两路同频信号的相位关系：
1. 切换到测量模式（Mode:M）
2. 系统自动计算并显示Phase值
3. Phase = angle(CH1) - angle(CH2)
4. 示例: Phase:90.0° 表示CH1领先CH2 90度

=============================================================================
 硬件连接建议
=============================================================================

【基本连接】
CH1 (绿) ← 主信号/参考信号/触发源
CH2 (红) ← 次信号/待测信号/响应信号

【应用场景1: 滤波器测试】
CH1 ← 滤波器输入
CH2 ← 滤波器输出
触发: channel_sel=0 (输入信号触发)
显示: 切换对比输入输出波形差异

【应用场景2: 放大器测试】
CH1 ← 输入小信号
CH2 ← 输出放大信号
触发: channel_sel=0 (输入触发)
显示: display_channel=1 观察放大后波形

【应用场景3: 数字电路调试】
CH1 ← 时钟信号
CH2 ← 数据信号
触发: channel_sel=0 (时钟触发)
显示: display_channel=1 观察数据建立/保持时间

【应用场景4: 电源纹波测试】
CH1 ← 负载电流检测（分流电阻）
CH2 ← 电源输出电压
触发: channel_sel=0 (电流变化触发)
显示: display_channel=1 观察电流变化时电压纹波

=============================================================================
 寄存器状态速查表
=============================================================================

┌─────────────────┬──────────────┬──────────────────────────┐
│ 寄存器          │ 控制按键     │ 作用                     │
├─────────────────┼──────────────┼──────────────────────────┤
│ channel_sel     │ Button[3]    │ 0=CH1触发, 1=CH2触发     │
│                 │              │ (仅时域模式有效)         │
├─────────────────┼──────────────┼──────────────────────────┤
│ display_channel │ Button[6]    │ 0=显示CH1, 1=显示CH2     │
│                 │              │ (所有模式有效)           │
├─────────────────┼──────────────┼──────────────────────────┤
│ work_mode       │ Button[0]    │ 0=时域, 1=频域, 2=测量   │
├─────────────────┼──────────────┼──────────────────────────┤
│ trigger_mode    │ Button[4]    │ 0=Auto, 1=Normal         │
│                 │              │ (仅时域模式有效)         │
├─────────────────┼──────────────┼──────────────────────────┤
│ trigger_level   │ Button[1]/[2]│ 0-1023, 步进±10         │
│                 │              │ (仅时域模式有效)         │
├─────────────────┼──────────────┼──────────────────────────┤
│ run_flag        │ Button[1]/[2]│ 启动/停止数据采集        │
│                 │              │ (频域/测量模式)          │
└─────────────────┴──────────────┴──────────────────────────┘

=============================================================================
 总结
=============================================================================

【核心设计理念】
本系统的双通道设计遵循"全时采集，灵活选择"原则：

1. **硬件层**: 双ADC始终以1MHz同步采样
2. **缓存层**: 双FIFO独立存储，互不干扰
3. **处理层**: FFT时分复用，轮流处理两路
4. **触发层**: 单一触发源，双路同步捕获（时域模式）
5. **显示层**: 灵活选择显示源，一键切换

【优势】
✅ 零数据丢失 - 两路始终采集
✅ 时序精确 - 同步触发，无偏差
✅ 操作简单 - 按键分工明确
✅ 功能强大 - 相位差、时序分析、双谱对比

【使用口诀】
Button[3] 选触发源，哪路判断哪路管
Button[6] 选显示源，屏幕看谁按一按
时域模式双通道，触发同步不会乱
频域测量任意切，数据处理在后端

=============================================================================
