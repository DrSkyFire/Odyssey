# 频谱显示左侧拉伸问题诊断

**日期**: 2025-11-05  
**问题**: 频谱左侧（零点附近）横向拉伸，基波难以观察  
**影响**: 低频信号（<100kHz）频谱显示失真  

---

## 🔍 **问题分析**

### 当前频谱映射公式:

```verilog
// 目标：4096 bins映射到1227像素
// 理想比例：4096/1227 = 3.34 bins/pixel

// 当前实现（hdmi_display_ctrl.v Line 424）：
spectrum_addr <= (h_offset << 1) + h_offset + (h_offset >> 2) + (h_offset >> 4);
//             = 2h + h + h/4 + h/16
//             = 3.3125h

// 误差：(3.3125 - 3.34)/3.34 = -0.8%
```

### 问题根因:

**位移运算的量化误差在小数值时严重**:

| h_offset | 理想addr | 当前计算 | 实际addr | 误差 |
|----------|----------|----------|----------|------|
| 0 | 0 | 2×0+0+0+0 | 0 | 0 |
| 1 | 3.34 | 2×1+1+0+0 | **3** | -0.34 ❌ |
| 2 | 6.68 | 2×2+2+0+0 | **6** | -0.68 ❌ |
| 3 | 10.02 | 2×3+3+0+0 | **9** | -1.02 ❌ |
| 4 | 13.36 | 2×4+4+1+0 | **13** | -0.36 ❌ |
| 8 | 26.72 | 2×8+8+2+0 | **26** | -0.72 ❌ |
| 16 | 53.44 | 2×16+16+4+1 | **53** | -0.44 ❌ |
| 100 | 334 | 2×100+100+25+6 | **331** | -3 ⚠️ |
| 1000 | 3340 | 2×1000+1000+250+62 | **3312** | -28 ❌ |

**关键发现**:
- `h_offset >> 2` 在 h<4 时为0，损失0.25h
- `h_offset >> 4` 在 h<16 时为0，损失0.0625h
- 左侧bin[0-100]对应像素0-30，误差累积导致**显著拉伸**

---

## 🎯 **视觉效果**

### 当前问题:

```
频谱显示（频率→）：
零点  基波(1kHz)              100kHz
↓     ↓                       ↓
|█████|-------|---------------|-----...
 ↑拉伸  ↑本应在此
 5像素  被压缩到1像素

实际：bin[0-3]占了5个像素（拉伸125%）
理想：bin[0-3]应占4个像素

结果：基波峰值（bin[0.234]）被拉伸成宽峰，难以观察精确位置
```

### 对低频信号的影响:

```
1kHz信号：bin[0.234]
  理想显示：像素0-1之间的亮点
  实际显示：像素0-2的宽条（拉伸200%）❌
  
20kHz信号：bin[4.68]
  理想显示：像素1-2之间的亮点
  实际显示：像素1-3的宽条（拉伸150%）❌
  
100kHz信号：bin[23.4]
  理想显示：像素7的亮点
  实际显示：像素6-7的宽点（拉伸130%）⚠️
  
1MHz信号：bin[234]
  理想显示：像素70的亮点
  实际显示：像素69-70的点（拉伸105%）✅ 可接受
```

---

## 🔧 **解决方案**

### 方案A: 高精度定点乘法 ⭐⭐⭐（推荐）

**原理**:
```verilog
// 目标：h_offset × 3.34 = h_offset × (107/32)
// 107/32 = 3.34375，误差0.1%

// 实现：先乘107，再右移5位
// 107 = 64 + 32 + 8 + 2 + 1
spectrum_addr <= ((h_offset << 6) + (h_offset << 5) + (h_offset << 3) + 
                  (h_offset << 1) + h_offset) >> 5;
```

**误差分析**:
| h_offset | 理想addr | 新计算(×107/32) | 误差 |
|----------|----------|-----------------|------|
| 1 | 3.34 | 3.34 | 0 ✅ |
| 2 | 6.68 | 6.69 | +0.01 ✅ |
| 4 | 13.36 | 13.38 | +0.02 ✅ |
| 10 | 33.4 | 33.44 | +0.04 ✅ |
| 100 | 334 | 334.38 | +0.38 ✅ |
| 1000 | 3340 | 3343.75 | +3.75 ⚠️ |

**优点**:
- ✅ 低频段（h<100）误差<1%
- ✅ 只用移位和加法，无乘法器
- ✅ 时序安全（5级加法树）

**缺点**:
- ⚠️ 高频段（h>1000）误差达1.1‰
- ⚠️ 5个移位+4个加法，资源消耗中等

---

### 方案B: 查找表（LUT） ⭐⭐

**原理**:
```verilog
// 预计算h_offset→spectrum_addr映射表
// RAM存储1228个13位值 = 1228×13bit = 2KB

reg [12:0] spectrum_lut [0:1227];

initial begin
    $readmemh("spectrum_addr_lut.hex", spectrum_lut);
end

// 查表（1周期）
spectrum_addr <= spectrum_lut[h_offset];
```

**优点**:
- ✅ 精度完美（误差0）
- ✅ 延迟1周期（vs当前0周期）
- ✅ 可用于任意非线性映射

**缺点**:
- ❌ 消耗2KB RAM（M9K/BRAM）
- ❌ 需要预生成LUT文件
- ❌ 增加1周期延迟

---

### 方案C: 流水线乘法 ⭐

**原理**:
```verilog
// 使用DSP乘法器：h_offset × 3340，然后÷1000
// 紫光同创PGL50H有DSP单元

reg [23:0] mult_result;  // h_offset × 3340
always @(posedge clk_pixel) begin
    mult_result <= h_offset * 24'd3340;
end

// 除法可用右移近似：÷1024 ≈ ÷1000（误差2.4%）
spectrum_addr <= mult_result >> 10;
```

**缺点**:
- ❌ 消耗DSP资源
- ❌ 除法仍有误差
- ❌ 增加2周期延迟

---

## 📋 **推荐实施方案A**

### 代码修改（hdmi_display_ctrl.v）:

```verilog
// Line 424附近，替换为：

// 【v11修复】高精度频谱地址映射，解决左侧拉伸问题
// 目标：spectrum_addr = h_offset × 3.34
// 实现：h_offset × (107/32) = 3.34375，误差0.1%
// 107 = 64 + 32 + 8 + 2 + 1
reg [18:0] addr_mult_107;  // 中间变量，最大1227×107=131289

always @(*) begin
    // 组合逻辑计算 h_offset × 107
    addr_mult_107 = (h_offset << 6) + (h_offset << 5) + (h_offset << 3) + 
                    (h_offset << 1) + h_offset;
end

// 频谱模式地址计算
if (work_mode != 2'b00) begin
    spectrum_addr <= addr_mult_107[18:5];  // ÷32（右移5位）
end
```

### 时序优化:

如果5级加法造成时序违例，可改为流水线：

```verilog
reg [18:0] addr_mult_107_stage1;
reg [18:0] addr_mult_107_stage2;

always @(posedge clk_pixel) begin
    // 第1级：计算64h + 32h + 8h
    addr_mult_107_stage1 <= (h_offset << 6) + (h_offset << 5) + (h_offset << 3);
    
    // 第2级：加上2h + h
    addr_mult_107_stage2 <= addr_mult_107_stage1 + (h_offset << 1) + h_offset;
    
    // 输出
    spectrum_addr <= addr_mult_107_stage2[18:5];
end
```

---

## 🧪 **验证测试**

### 测试方法:

1. **显示刻度线**（如果有）
   - 检查0, 100kHz, 500kHz, 1MHz刻度是否对齐
   
2. **1kHz正弦波**
   - 基波应显示为**单像素宽**的尖峰
   - 当前可能显示为2-3像素宽的宽峰
   
3. **20kHz方波**
   - 基波bin[4.68]应在像素1-2之间
   - 3次谐波bin[14.04]应在像素4
   - 5次谐波bin[23.4]应在像素7

### 成功标准:

- ✅ 1kHz峰值宽度从3像素→1像素
- ✅ 低频段（0-100kHz）刻度线性
- ✅ 谐波位置符合理论计算

---

## 🔍 **低频噪声问题（额外）**

除了显示拉伸，你提到**低频噪声严重**。可能原因：

### 1. DC偏置去除不彻底

**检查**：
```verilog
// dual_channel_fft_controller.v Line 200附近
// 当前使用ADC_OTR去除DC，但可能不足

// 建议：增加动态DC跟踪
reg [15:0] dc_avg;  // DC平均值（16帧）
always @(posedge clk) begin
    dc_avg <= dc_avg + ((adc_data - dc_avg) >> 4);  // IIR低通
end
assign adc_ac = adc_data - dc_avg;  // 去除动态DC
```

### 2. FFT泄漏（已知问题）

**解决**：
- v11的8帧平均应该能降低69%噪声
- 如果仍不足，增加到16帧（延迟400ms）

### 3. 频谱显示动态范围

**检查幅度缩放**：
```verilog
// 如果频谱显示使用对数缩放，低幅度噪声会被放大显示
// 建议：增加噪声门限，<阈值的bin显示为0
```

---

## 🎯 **实施优先级**

1. **立即修复**：频谱地址映射（方案A，30分钟）
2. **测试v11**：8帧平均是否降低噪声
3. **如果噪声仍严重**：
   - 增加到16帧平均（5分钟修改）
   - 或检查DC去除和动态范围

**需要我实施方案A的代码修改吗？**
