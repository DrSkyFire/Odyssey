# 测量异常根因分析报告

## 📊 问题现象总结

| 测试项 | 设定值 | 实测值 | 误差 | 状态 |
|--------|--------|--------|------|------|
| 频率-100Hz | 100Hz | 46992Hz | 470倍 | ❌ 严重异常 |
| 频率-1kHz | 1kHz | 闪烁 | - | ❌ 无法读数 |
| 频率-10kHz | 10kHz | 40-50kHz闪烁 | 4-5倍 | ❌ 严重异常 |
| 频率-100kHz | 100kHz | 68.01kHz | 32% | ❌ 偏差大 |
| 频率-1MHz | 1MHz | 10kHz | 100倍 | ❌ 完全错误 |
| 幅度-100mVpp | 100mV | 40mV | 60% | ❌ 严重偏低 |
| 幅度-1Vpp | 1V | 36-40mV | 96% | ❌ 严重偏低 |
| 幅度-3.3Vpp | 3.3V | 0-700mV | 79% | ❌ 严重偏低 |
| THD-正弦波 | <5% | 0% | - | ✅ 合理 |
| THD-方波 | >30% | 0% | - | ❌ 应有谐波 |
| 占空比-50% | 50% | 22.4% | -27.6% | ❌ 严重偏低 |
| 占空比-80% | 80% | 41.9% | -38.1% | ❌ 严重偏低 |

---

## 🔍 根因分析

### ✅ 已排除的可能性

#### 1. 工作模式错误（已确认）
- ✅ 代码设置: `work_mode <= 2'd1;` (频域模式)
- ✅ HDMI显示: 频谱图（确认在FFT模式）
- ✅ FFT启动条件: `fft_start = run_flag && (work_mode == 2'd1)` ✓

#### 2. 测试模式误启用（已确认）
- ✅ LED[5] = 灭 (test_mode = 0)
- ✅ 系统测量外部信号，不是内部测试信号

---

### ⚠️ **核心问题：FFT频谱数据未生效**

#### 代码逻辑分析（signal_parameter_measure.v）

```verilog
// Line 1111-1126: 输出逻辑
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        freq_out <= 16'd0;
        amplitude_out <= 16'd0;
    end else if (measure_en) begin
        // 【关键】优先使用FFT频率和幅度
        if (fft_freq_ready && use_fft_freq) begin
            // FFT模式输出
            freq_out <= (fft_freq_hz >= 100kHz) ? (fft_freq_hz/100) : fft_freq_hz;
            amplitude_out <= fft_max_amp;  // FFT基波幅度
        end else if (measure_done) begin
            // 【回退】时域测量输出
            freq_out <= freq_calc;        // 过零检测频率 ← 当前在用这个！
            amplitude_out <= amplitude_calc;  // 峰峰值 ← 当前在用这个！
        end
    end
end
```

#### 问题定位

**当前系统正在使用时域测量数据（过零检测），而不是FFT数据！**

证据：
1. **频率完全错误** → 过零检测算法有问题
2. **幅度严重偏低** → 时域峰峰值测量不准
3. **THD恒为0%** → FFT谐波检测未工作
4. **占空比测量值≈设定值50%** → 时域占空比算法有bug

---

### 🎯 **问题根源：spectrum_valid 未激活**

#### FFT峰值检测逻辑（Line 388-412）

```verilog
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        fft_freq_ready <= 1'b0;
        use_fft_freq <= 1'b0;
    end else if (measure_en && spectrum_valid) begin  // ← 关键条件！
        if (spectrum_addr == 13'd0) begin
            fft_scan_active <= 1'b1;
            use_fft_freq <= 1'b1;  // 标记使用FFT
        end
        // ... 峰值扫描 ...
        else if (spectrum_addr == (FFT_POINTS/2)) begin
            fft_freq_ready <= 1'b1;  // FFT就绪
        end
    end else begin
        fft_freq_ready <= 1'b0;  // ← spectrum_valid=0时持续清零！
    end
end
```

**核心问题**：
- `fft_freq_ready` 的生成依赖 `spectrum_valid`
- 如果 `spectrum_valid` 一直为0，则 `fft_freq_ready` 永远为0
- 输出逻辑永远进不了 `if (fft_freq_ready && use_fft_freq)` 分支
- **系统一直使用时域测量数据！**

---

## 🛠️ 可能原因排查

### 原因1：FFT处理器未启动（70%概率）

#### 检查点：
```verilog
// signal_analyzer_top.v Line 1870
assign fft_start = run_flag && (work_mode == 2'd1);
```

**验证方法**：
- 检查 `run_flag` 是否为1 → LED[0] 应该亮
- 检查 `work_mode` 是否为2'd1 → 需要添加LED指示（已修改）

**可能问题**：
- 虽然代码设置了 `work_mode <= 2'd1`，但可能在综合时被优化
- 按键逻辑可能把 `work_mode` 改成了其他值

---

### 原因2：FFT IP核配置错误（20%概率）

#### 可能问题：
- FFT IP核的输出使能未配置
- FFT IP核的数据格式不匹配
- FFT IP核的流控握手异常

#### 验证方法：
需要查看FFT IP核的配置文件（在 `ipcore/fft_8192/` 目录）

---

### 原因3：spectrum_valid信号路径断开（10%概率）

#### 检查点：
```verilog
// signal_analyzer_top.v Line 810, 1414
fft_processor u_fft_processor (
    .ch1_spectrum_valid (ch1_spectrum_valid),  // 输出
    ...
);

signal_parameter_measure u_ch1_measure (
    .spectrum_valid (ch1_spectrum_valid),      // 输入
    ...
);
```

连接看起来正常，但可能在综合时被优化掉。

---

## 🚀 修复方案

### 方案A：添加work_mode LED指示（已完成 ✅）

```verilog
// 修改 LED 分配
user_led_reg[3] <= work_mode[0];  // 工作模式 bit0
user_led_reg[4] <= work_mode[1];  // 工作模式 bit1
```

**期望结果**：
- LED[3] = 1, LED[4] = 0 → work_mode = 2'b01 (频域模式) ✅
- 如果不是这个状态 → work_mode被错误修改

---

### 方案B：添加spectrum_valid LED指示（下一步）

```verilog
// 临时诊断：把LED[3]或LED[4]改为spectrum_valid
user_led_reg[3] <= ch1_spectrum_valid;  // FFT数据有效指示
```

**期望结果**：
- LED[3] 应该周期性闪烁（每100ms一次FFT扫描）
- 如果一直是灭的 → FFT处理器未输出数据

---

### 方案C：强制使能FFT（临时诊断）

在 `signal_analyzer_top.v` 中强制启动FFT：

```verilog
// Line 1870 附近修改：
assign fft_start = 1'b1;  // 强制启动FFT（临时诊断）
```

**如果修改后测量正常** → 证明是 `run_flag` 或 `work_mode` 的问题

---

### 方案D：添加调试端口（推荐）

在顶层添加UART调试输出：

```verilog
// 每秒输出一次关键信号状态
UART输出内容：
- work_mode
- run_flag
- fft_start
- ch1_spectrum_valid
- fft_freq_ready
- use_fft_freq
```

---

## 📋 下一步行动计划

### 立即执行（5分钟）

1. **编译并下载修改后的代码**
   - LED[3][4] 现在显示 work_mode

2. **观察LED灯状态**
   - LED[3] = ? 
   - LED[4] = ?
   - 期望: LED[3]=1, LED[4]=0 (work_mode=01)

3. **如果LED显示work_mode=01**
   - 说明工作模式正确
   - 问题在FFT处理器或spectrum_valid

4. **如果LED显示work_mode≠01**
   - 说明work_mode被意外修改
   - 需要检查按键逻辑或综合优化

---

### 第二步诊断（10分钟）

如果work_mode正确，添加spectrum_valid指示：

```verilog
user_led_reg[2] <= ch1_spectrum_valid;  // 替代OTR指示
```

- 如果LED[2]闪烁 → FFT有输出，问题在测量模块
- 如果LED[2]常灭 → FFT未输出，问题在FFT处理器

---

### 第三步修复（30分钟）

根据诊断结果：
- **FFT未输出** → 检查FFT IP核配置
- **FFT有输出但测量错误** → 检查频率计算公式
- **时域测量算法bug** → 修复过零检测和占空比算法

---

## 🎯 预期效果

修复后应该达到：
- ✅ 频率精度 <0.1% (FFT模式)
- ✅ 幅度精度 ±1%
- ✅ THD能正确区分正弦波和方波
- ✅ 占空比精度 ±0.5%
- ✅ 测量值不再闪烁抖动

---

**当前状态：等待重新编译下载，观察LED[3][4]的状态**
