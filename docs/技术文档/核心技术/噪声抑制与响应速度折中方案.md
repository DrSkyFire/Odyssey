# 噪声抑制与响应速度折中方案

## 📋 报告信息
- **日期**：2025年11月6日
- **问题**：滑动平均滤波导致响应慢 vs 噪声抑制需求
- **目标**：在噪声抑制和响应速度之间找到最佳平衡点
- **分析人**：GitHub Copilot

---

## 🎯 核心矛盾分析

### 当前困境
```
噪声抑制强 ←→ 响应速度快
     ↑              ↑
  8次滑动平均    无滤波
  (800ms延迟)   (噪声大)
```

您当前使用的**多级滑动平均滤波**确实是应对噪声的标准方法，但代价是响应速度慢。

---

## ✅ 您已经在使用的技术（非常好！）

### 1. FFT加窗（Hann窗）✅
**位置**: `dual_channel_fft_controller.v` 第90-101行

```verilog
// Hann窗函数相关信号
reg  [15:0] hann_window_rom [0:8191];  // Hann窗系数ROM
reg  [15:0] window_coeff;              // 窗系数寄存器
wire signed [15:0] windowed_data;      // 加窗后的数据

initial begin
    $readmemh("source/hann_window_8192.hex", hann_window_rom);
end
```

**作用**:
- ✅ **频谱泄漏抑制**：将矩形窗的-13dB旁瓣改善到Hann窗的-31dB
- ✅ **频率分辨率**：减少能量泄漏到相邻频率bin
- ✅ **谐波检测精度**：提高THD测量的准确性

**结论**: 您的FFT加窗已经做得很好了！这是频域降噪的标准做法。

---

## 💡 折中方案（推荐组合）

### 方案A: 指数移动平均（EMA）替代滑动平均 ⭐⭐⭐⭐⭐

#### 核心思想
用**一阶IIR滤波器**替代FIR滑动平均滤波器，实现：
- ✅ 响应速度可调（通过α系数）
- ✅ 资源消耗更少（无需历史数组）
- ✅ 噪声抑制能力可控

#### 数学原理
```
传统滑动平均（FIR）:
  y[n] = (x[n] + x[n-1] + x[n-2] + x[n-3]) / 4
  延迟：4个周期 = 400ms
  资源：4×16bit寄存器 + 加法器 + 除法器

指数移动平均（IIR）:
  y[n] = α × x[n] + (1-α) × y[n-1]
  延迟：1个周期 = 100ms（63%响应）
  资源：1×16bit寄存器 + 1个乘法器
```

#### α系数选择
| α值 | 等效窗口 | 响应时间（63%） | 响应时间（95%） | 噪声抑制 |
|-----|---------|----------------|----------------|---------|
| 0.5 | ≈2次平均 | 100ms | 300ms | 中等 ⭐⭐⭐ |
| 0.25 | ≈4次平均 | 200ms | 600ms | 良好 ⭐⭐⭐⭐ |
| 0.125 | ≈8次平均 | 400ms | 1200ms | 优秀 ⭐⭐⭐⭐⭐ |

**推荐值**: α = 0.25（等效4次平均，但响应速度提升30%）

#### Verilog实现（频率滤波器示例）

```verilog
//=============================================================================
// 方案A: 指数移动平均滤波器（替代滑动平均）
//=============================================================================
// 参数定义
localparam ALPHA_SHIFT = 2;  // α = 1/4 = 0.25（右移2位）

// 寄存器定义
reg [15:0] freq_ema;         // EMA滤波器输出
reg [16:0] freq_error;       // 误差 = x[n] - y[n-1]
reg [16:0] freq_delta;       // 增量 = α × 误差

// EMA滤波器
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        freq_ema <= 16'd0;
    end else if (freq_result_done) begin
        // 计算误差（带符号扩展）
        freq_error <= {1'b0, freq_result} - {1'b0, freq_ema};
        
        // 计算增量 δ = α × error = error / 4（右移2位）
        freq_delta <= freq_error >>> ALPHA_SHIFT;
        
        // 更新EMA：y[n] = y[n-1] + δ
        freq_ema <= freq_ema + freq_delta[15:0];
    end
end

// 输出
assign freq_filtered = freq_ema;
```

**优点**:
- ✅ 响应速度提升30-50%
- ✅ 资源消耗降低75%（无需历史数组）
- ✅ 平滑效果依然良好
- ✅ 实现简单，修改量小

**缺点**:
- ⚠️ 对突变信号的响应是指数衰减（不如滑动平均的线性响应）

---

### 方案B: 自适应滤波器（智能切换） ⭐⭐⭐⭐⭐

#### 核心思想
**根据信号变化速度自动调整滤波强度**：
- 信号快速变化 → 弱滤波（快速响应）
- 信号稳定 → 强滤波（噪声抑制）

#### Verilog实现（频率滤波器示例）

```verilog
//=============================================================================
// 方案B: 自适应EMA滤波器
//=============================================================================
// 参数定义
localparam THRESHOLD_FAST = 16'd1000;   // 快速变化阈值（10%）
localparam THRESHOLD_SLOW = 16'd100;    // 慢速变化阈值（1%）

// 寄存器定义
reg [15:0] freq_ema;              // EMA输出
reg [15:0] freq_change_rate;      // 变化率
reg [2:0]  alpha_shift;           // 动态α系数（移位量）

// 变化率检测
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        freq_change_rate <= 16'd0;
    end else if (freq_result_done) begin
        // 计算绝对变化率
        freq_change_rate <= (freq_result > freq_ema) ? 
                           (freq_result - freq_ema) : 
                           (freq_ema - freq_result);
    end
end

// 自适应α系数选择
always @(*) begin
    if (freq_change_rate > THRESHOLD_FAST) begin
        // 快速变化：α = 0.5（右移1位）
        alpha_shift = 3'd1;
    end else if (freq_change_rate > THRESHOLD_SLOW) begin
        // 中速变化：α = 0.25（右移2位）
        alpha_shift = 3'd2;
    end else begin
        // 稳定状态：α = 0.125（右移3位）
        alpha_shift = 3'd3;
    end
end

// 自适应EMA滤波器
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        freq_ema <= 16'd0;
    end else if (freq_result_done) begin
        // y[n] = y[n-1] + α × (x[n] - y[n-1])
        // α动态调整：快速变化时大，稳定时小
        freq_ema <= freq_ema + 
                   (((freq_result > freq_ema ? 
                      freq_result - freq_ema : 
                      freq_ema - freq_result) >>> alpha_shift));
    end
end

assign freq_filtered = freq_ema;
```

**优点**:
- ✅ 快速信号：响应时间<200ms
- ✅ 稳定信号：噪声抑制等效8次平均
- ✅ 自动平衡，无需手动调参
- ✅ 用户体验最佳

**缺点**:
- ⚠️ 实现复杂度中等
- ⚠️ 需要调试阈值参数

---

### 方案C: 加权移动平均（WMA） ⭐⭐⭐⭐

#### 核心思想
**对历史数据加权**，近期数据权重大，远期数据权重小。

#### 数学原理
```
传统滑动平均（SMA）:
  y = (x₀ + x₁ + x₂ + x₃) / 4
  权重：[1, 1, 1, 1]

加权移动平均（WMA）:
  y = (4×x₀ + 3×x₁ + 2×x₂ + 1×x₃) / 10
  权重：[4, 3, 2, 1]
  
响应提升：最新数据占40%权重（vs SMA的25%）
```

#### Verilog实现（占空比滤波器示例）

```verilog
//=============================================================================
// 方案C: 加权移动平均滤波器（4点）
//=============================================================================
reg [15:0] duty_history [0:3];  // 历史值缓存
reg [1:0]  duty_hist_ptr;       // 历史指针
reg [15:0] duty_wma;            // 加权平均输出

// 加权系数：[4, 3, 2, 1]，总和=10
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for (i = 0; i < 4; i = i + 1)
            duty_history[i] <= 16'd0;
        duty_hist_ptr <= 2'd0;
        duty_wma <= 16'd0;
    end else if (duty_pipe_valid[2]) begin
        // 更新历史缓存
        duty_history[duty_hist_ptr] <= duty_result;
        duty_hist_ptr <= duty_hist_ptr + 1'b1;
        
        // 计算加权平均（使用移位优化除以10）
        // y = (4×x₀ + 3×x₁ + 2×x₂ + 1×x₃) / 10
        // 近似：/ 10 ≈ × 0.1 ≈ × 26/256 ≈ 右移4位后×13再右移4位
        reg [18:0] weighted_sum;
        weighted_sum = (duty_result << 2) +                    // 4×x₀
                      (duty_history[(duty_hist_ptr-1)&2'b11] << 1) + duty_history[(duty_hist_ptr-1)&2'b11] +  // 3×x₁
                      (duty_history[(duty_hist_ptr-2)&2'b11] << 1) +  // 2×x₂
                      duty_history[(duty_hist_ptr-3)&2'b11];          // 1×x₃
        
        // 除以10的近似实现：× 6554 / 65536 ≈ / 10.00015
        duty_wma <= (weighted_sum * 16'd6554) >> 16;
    end
end

assign duty_filtered = duty_wma;
```

**优点**:
- ✅ 响应速度提升约40%（vs等点数SMA）
- ✅ 保留历史平滑特性
- ✅ 噪声抑制能力仅略微下降

**缺点**:
- ⚠️ 实现比EMA复杂
- ⚠️ 需要历史数组（但比SMA小）

---

### 方案D: 中值滤波 + 轻度平滑 ⭐⭐⭐

#### 核心思想
**中值滤波去除脉冲噪声，再用2次平均做轻度平滑**。

#### 适用场景
- 存在脉冲干扰（如电机启动、继电器动作）
- 需要去除异常值

#### Verilog实现（3点中值滤波 + 2次平均）

```verilog
//=============================================================================
// 方案D: 中值滤波 + 轻度EMA
//=============================================================================
// 3点中值滤波（去除脉冲噪声）
reg [15:0] freq_median_buf [0:2];
reg [1:0]  median_ptr;
reg [15:0] freq_median;

// 中值滤波（选择3个值中的中间值）
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        median_ptr <= 2'd0;
        freq_median <= 16'd0;
        for (i = 0; i < 3; i = i + 1)
            freq_median_buf[i] <= 16'd0;
    end else if (freq_result_done) begin
        // 更新缓存
        freq_median_buf[median_ptr] <= freq_result;
        median_ptr <= (median_ptr == 2'd2) ? 2'd0 : median_ptr + 1'b1;
        
        // 计算中值（3个值排序取中间）
        if ((freq_median_buf[0] <= freq_median_buf[1] && freq_median_buf[1] <= freq_median_buf[2]) ||
            (freq_median_buf[2] <= freq_median_buf[1] && freq_median_buf[1] <= freq_median_buf[0]))
            freq_median <= freq_median_buf[1];
        else if ((freq_median_buf[1] <= freq_median_buf[0] && freq_median_buf[0] <= freq_median_buf[2]) ||
                 (freq_median_buf[2] <= freq_median_buf[0] && freq_median_buf[0] <= freq_median_buf[1]))
            freq_median <= freq_median_buf[0];
        else
            freq_median <= freq_median_buf[2];
    end
end

// 轻度EMA平滑（α=0.5）
reg [15:0] freq_ema;
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        freq_ema <= 16'd0;
    end else if (freq_result_done) begin
        // y[n] = 0.5 × median[n] + 0.5 × y[n-1]
        freq_ema <= (freq_median + freq_ema) >> 1;
    end
end

assign freq_filtered = freq_ema;
```

**优点**:
- ✅ 对脉冲噪声免疫
- ✅ 响应时间约200ms
- ✅ 保留真实信号的快速变化

**缺点**:
- ⚠️ 对高斯白噪声效果一般
- ⚠️ 实现复杂度高

---

## 🎯 FFT加窗是否能改善？

### 当前状况
您已经使用了**Hann窗**，这是FFT加窗的黄金标准：
```python
# generate_hann_window.py
window = 0.5 - 0.5 * np.cos(2 * np.pi * n / (N - 1))
```

### Hann窗特性
| 特性 | 性能 |
|------|------|
| 旁瓣衰减 | -31.5 dB ⭐⭐⭐⭐ |
| 主瓣宽度 | 1.5 bins |
| 频率精度 | 良好 |
| 幅度精度 | 良好（需×2补偿） |

### 其他窗函数对比

#### 1. Blackman-Harris窗 ⭐⭐⭐⭐⭐
```python
# 更好的噪声抑制
window = 0.35875 - 0.48829*cos(2*pi*n/N) + 
         0.14128*cos(4*pi*n/N) - 0.01168*cos(6*pi*n/N)
```
- 旁瓣衰减：-92 dB（vs Hann的-31 dB）
- 主瓣宽度：2 bins（vs Hann的1.5 bins）
- **适合场景**：弱信号检测、高噪声环境
- **代价**：频率分辨率略降

#### 2. Kaiser窗（可调参数β） ⭐⭐⭐⭐⭐
```python
from scipy.signal import kaiser
window = kaiser(N, beta)
# beta=5: 中等旁瓣抑制（-50 dB）
# beta=8.6: 强旁瓣抑制（-80 dB）
# beta=14: 极强旁瓣抑制（-120 dB）
```
- 优点：**可调节**，平衡频率分辨率和旁瓣抑制
- 适合场景：需要灵活权衡的应用

#### 3. 平顶窗（Flat-Top） ⭐⭐⭐
```python
window = 0.21557895 - 0.41663158*cos(2*pi*n/N) + 
         0.277263158*cos(4*pi*n/N) - 0.083578947*cos(6*pi*n/N) + 
         0.006947368*cos(8*pi*n/N)
```
- 幅度精度：±0.01 dB（vs Hann的±1.5 dB）
- **适合场景**：幅度测量优先
- **代价**：频率分辨率降低50%

### 加窗改进建议

#### 建议1: 如果噪声主要来自谐波干扰
**推荐**：保持Hann窗 ✅  
**原因**：Hann窗已经足够好，-31 dB旁瓣抑制对谐波充分

#### 建议2: 如果噪声是宽带白噪声
**推荐**：升级到Blackman-Harris窗 ⭐⭐⭐⭐⭐  
**修改**：替换`generate_hann_window.py`中的窗函数
```python
# 在generate_hann_window.py中替换
def generate_blackman_harris_window(N=8192):
    n = np.arange(N)
    a0 = 0.35875
    a1 = 0.48829
    a2 = 0.14128
    a3 = 0.01168
    window = (a0 - 
              a1 * np.cos(2*np.pi*n/(N-1)) + 
              a2 * np.cos(4*np.pi*n/(N-1)) - 
              a3 * np.cos(6*np.pi*n/(N-1)))
    return window
```

**效果预测**：
- ✅ 噪声抑制提升**60 dB**（-31 dB → -92 dB）
- ✅ THD测量准确度提升（谐波更清晰）
- ⚠️ 频率分辨率略降（1.5 bins → 2 bins）
- ⚠️ 需要重新生成窗系数文件

#### 建议3: 如果幅度测量精度不够
**推荐**：升级到Flat-Top窗 ⭐⭐⭐  
**效果**：幅度误差从±1%降低到±0.01%

---

## 📊 综合方案对比

| 方案 | 响应时间 | 噪声抑制 | 资源消耗 | 实现难度 | 推荐度 |
|------|---------|---------|---------|---------|--------|
| **当前（8次SMA）** | 800ms | ⭐⭐⭐⭐⭐ | 高 | 简单 | ⭐⭐ |
| **A. EMA（α=0.25）** | 200ms | ⭐⭐⭐⭐ | 低 | 简单 | ⭐⭐⭐⭐⭐ |
| **B. 自适应EMA** | 100-400ms | ⭐⭐⭐⭐⭐ | 低 | 中等 | ⭐⭐⭐⭐⭐ |
| **C. WMA（4点）** | 300ms | ⭐⭐⭐⭐ | 中 | 中等 | ⭐⭐⭐⭐ |
| **D. 中值+EMA** | 200ms | ⭐⭐⭐⭐ | 中 | 复杂 | ⭐⭐⭐ |
| **升级窗函数** | - | ⭐⭐⭐⭐⭐ | - | 中等 | ⭐⭐⭐⭐ |

---

## 🛠️ 推荐实施路线图

### 阶段1：立即实施（风险低，效果显著）⭐⭐⭐⭐⭐
**方案A：用EMA替代滑动平均**
- 修改4处滤波器：频率、幅度、占空比、THD
- α系数：0.25（等效4次平均）
- 预期改善：
  - 响应时间：400ms → 200ms
  - 资源节省：75%
  - 噪声抑制：略微下降（可接受）

### 阶段2：优化提升（风险中，效果优秀）⭐⭐⭐⭐⭐
**方案B：实现自适应EMA**
- 仅对频率和幅度应用（关键参数）
- 占空比和THD保持固定EMA
- 预期改善：
  - 快速响应：<200ms
  - 稳定噪声抑制：等效8次平均
  - 用户体验最佳

### 阶段3：专项优化（可选，针对特定噪声）⭐⭐⭐⭐
**升级FFT窗函数**
- 如果存在强噪声：Blackman-Harris窗
- 如果幅度精度不足：Flat-Top窗
- 修改`generate_hann_window.py`
- 重新生成窗系数文件

---

## 🔧 EMA实现代码（完整示例）

### 频率滤波器（推荐）

```verilog
//=============================================================================
// 频率EMA滤波器（α=0.25，等效4次平均）
//=============================================================================
localparam FREQ_ALPHA_SHIFT = 2;  // α = 1/4 = 0.25

reg [15:0] freq_ema;
reg signed [16:0] freq_error;  // 误差（带符号）

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        freq_ema <= 16'd0;
    end else begin
        // 检测单位切换，清空滤波器
        if (freq_unit_d2 != freq_unit_d3) begin
            freq_ema <= 16'd0;
        end
        else if (freq_result_done) begin
            // 计算误差（带符号扩展）
            freq_error <= $signed({1'b0, freq_result}) - $signed({1'b0, freq_ema});
            
            // 更新EMA：y[n] = y[n-1] + α × (x[n] - y[n-1])
            //              = y[n-1] + error >> ALPHA_SHIFT
            freq_ema <= freq_ema + freq_error[16:FREQ_ALPHA_SHIFT];
        end
    end
end

assign freq_filtered = freq_ema;
```

### 幅度滤波器

```verilog
//=============================================================================
// 幅度EMA滤波器（α=0.25）
//=============================================================================
localparam AMP_ALPHA_SHIFT = 2;

reg [15:0] amp_ema;
reg signed [16:0] amp_error;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        amp_ema <= 16'd0;
    end else if (amp_pipe_valid[1]) begin
        amp_error <= $signed({1'b0, amp_result}) - $signed({1'b0, amp_ema});
        amp_ema <= amp_ema + amp_error[16:AMP_ALPHA_SHIFT];
    end
end

assign amp_filtered = amp_ema;
```

### 占空比滤波器（α=0.125，更强平滑）

```verilog
//=============================================================================
// 占空比EMA滤波器（α=0.125，等效8次平均）
//=============================================================================
localparam DUTY_ALPHA_SHIFT = 3;  // α = 1/8

reg [15:0] duty_ema;
reg signed [16:0] duty_error;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        duty_ema <= 16'd0;
    end else if (duty_pipe_valid[2]) begin
        duty_error <= $signed({1'b0, duty_result}) - $signed({1'b0, duty_ema});
        duty_ema <= duty_ema + duty_error[16:DUTY_ALPHA_SHIFT];
    end
end

assign duty_filtered = duty_ema;
```

### THD滤波器（α=0.125）

```verilog
//=============================================================================
// THD EMA滤波器（α=0.125）
//=============================================================================
localparam THD_ALPHA_SHIFT = 3;

reg [15:0] thd_ema;
reg signed [16:0] thd_error;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        thd_ema <= 16'd0;
    end else if (thd_pipe_valid[2]) begin
        thd_error <= $signed({1'b0, thd_calc}) - $signed({1'b0, thd_ema});
        thd_ema <= thd_ema + thd_error[16:THD_ALPHA_SHIFT];
    end
end

assign thd_filtered = thd_ema;
```

---

## ✅ 测试验证清单

### 1. EMA性能测试
- [ ] 频率阶跃响应：1kHz → 10kHz
  - 目标：63%响应<200ms，95%响应<600ms
- [ ] 幅度阶跃响应：1V → 2V
  - 目标：63%响应<200ms
- [ ] 噪声抑制：1kHz + 白噪声（SNR=20dB）
  - 目标：频率抖动<±20Hz（vs当前<±10Hz）

### 2. 资源消耗对比
- [ ] BRAM使用：预期减少75%
  - 当前：4×4 + 8×2 = 32个16bit寄存器
  - EMA：4个16bit寄存器
- [ ] 逻辑资源：预期减少50%

### 3. 窗函数升级测试（可选）
- [ ] Blackman-Harris窗vs Hann窗
  - THD测量准确度对比
  - 弱信号检测能力对比

---

## 📝 总结

### 核心问题
✅ **您的噪声抑制策略是正确的**，但滑动平均导致响应慢

### 推荐方案
⭐ **方案A（EMA）+ 方案B（自适应）** 组合：
1. 立即实施EMA替代滑动平均
   - α = 0.25（频率、幅度）
   - α = 0.125（占空比、THD）
2. 后续升级为自适应EMA（频率、幅度）
3. 如有需要，升级FFT窗函数

### 预期改善
- 响应速度：**提升2-4倍**（400ms → 100-200ms）
- 噪声抑制：**略微下降**（可接受）
- 资源消耗：**节省75%**
- 用户体验：**显著提升**

### FFT加窗
- 当前Hann窗已经很好 ✅
- 如需进一步降噪，可升级到Blackman-Harris窗
- 加窗改善的是**频域噪声**，对时域测量（频率、占空比）帮助有限

---

**下一步行动**：我可以帮您实施EMA滤波器的代码修改，是否需要？
