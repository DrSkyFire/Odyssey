# THD修复v10: 精确谐波bin计算

**日期**: 2025-11-05  
**问题**: 20kHz方波THD=0%, 1MHz方波THD=20%偏低  
**根因**: 整数bin倍数计算在低频时误差累积严重  
**修复**: 基于频率倍数而非bin索引倍数计算谐波bin

---

## 📋 问题回顾

### v9版本测试结果:
| 频率 | 波形 | THD测量 | THD理论 | 状态 |
|------|------|---------|---------|------|
| 600kHz | 方波 | 53%±3% | 48.3% | ✅ 准确 |
| 500kHz | 正弦波 | 8.0%±3% | <1% | ⚠️ 偏高 |
| 1MHz | 方波 | 20%±1% | 48.3% | ⚠️ 偏低 |
| **20kHz** | **方波** | **0.0%** | **48.3%** | **❌ 完全失败** |

---

## 🔍 根因分析

### 当前实现（v9）:
```verilog
// 问题代码：使用bin索引的整数倍
harm2_bin <= (fft_peak_bin << 1);                    // bin×2
harm3_bin <= (fft_peak_bin << 1) + fft_peak_bin;     // bin×3
harm4_bin <= (fft_peak_bin << 2);                    // bin×4
harm5_bin <= (fft_peak_bin << 2) + fft_peak_bin;     // bin×5
```

### 误差分析:

#### 20kHz方波（THD=0%失败）:
```
FFT参数:
  采样率: 35MHz
  FFT点数: 8192
  频率分辨率: 4272.46 Hz/bin

基波检测:
  实际频率: 20kHz
  理论bin: 20000 / 4272 = 4.681
  FFT检测: bin[4] 或 bin[5] （取决于窗函数泄漏）

如果检测为 bin[4]:
  3次谐波: 4 × 3 = 12
    理论bin: (20kHz × 3) / 4272 = 14.04
    误差: |12 - 14.04| = 2.04 bin ❌
    搜索范围: bin[9..15]，理论bin[14]在范围内
    但bin[12]附近能量弱，可能检测不到

  5次谐波: 4 × 5 = 20
    理论bin: (20kHz × 5) / 4272 = 23.41
    误差: |20 - 23.41| = 3.41 bin ❌❌
    搜索范围: bin[17..23]，理论bin[23]刚好在边缘
    高概率检测失败

如果检测为 bin[5]:
  3次谐波: 5 × 3 = 15
    理论bin: 14.04
    误差: |15 - 14.04| = 0.96 bin ⚠️
  
  5次谐波: 5 × 5 = 25
    理论bin: 23.41
    误差: |25 - 23.41| = 1.59 bin ⚠️
```

#### 600kHz方波（THD=53%正常）:
```
基波检测:
  实际频率: 600kHz
  理论bin: 600000 / 4272 = 140.43
  FFT检测: bin[140]

谐波计算:
  3次: 140 × 3 = 420, 理论 421.30, 误差 1.30 bin ✅
  5次: 140 × 5 = 700, 理论 702.17, 误差 2.17 bin ✅
  
误差在±3bin搜索范围内，检测成功 ✅
```

### 结论:
- ✅ **高频（bin>100）**: 误差<3bin，可以找到谐波
- ❌ **低频（bin<10）**: 误差>3bin，谐波检测失败
- **根本原因**: `bin×N` 是整数运算，忽略了基波频率的小数部分

---

## 🔧 修复方案

### 核心思想:
**使用频率倍数而非bin索引倍数计算谐波位置**

```verilog
// v9版本（错误）: 
harm3_bin <= fft_peak_bin × 3;  // 整数倍，累积误差

// v10版本（正确）:
harm3_bin <= (fft_freq_hz × 3) / FREQ_RES;  // 频率倍数，精确
```

### 实现细节:

```verilog
// 【v10修复】精确谐波bin计算：基于频率而非bin整数倍
// 修复原因：低频时bin索引小(如20kHz→bin[5])，整数倍误差大
//   例：bin[5]×3=15, 但理论bin[14.04]，误差0.96bin
//       bin[4]×3=12, 但理论bin[14.04]，误差2.04bin ❌
// 新方案：freq×N / FREQ_RES，精确到小数
//   例：20kHz×3=60kHz, 60000/4272=14.04, 四舍五入=14 ✅

// 计算谐波频率（Hz）：基波频率 × 谐波次数
// fft_freq_hz 已在2B阶段计算好，范围0-17.5MHz，18位足够
harm2_bin <= ((fft_freq_hz << 1) + (FREQ_RES >> 1)) / FREQ_RES;  // freq×2 / 4272 (四舍五入)
harm3_bin <= ((fft_freq_hz * 3) + (FREQ_RES >> 1)) / FREQ_RES;   // freq×3 / 4272
harm4_bin <= ((fft_freq_hz << 2) + (FREQ_RES >> 1)) / FREQ_RES;  // freq×4 / 4272
harm5_bin <= ((fft_freq_hz * 5) + (FREQ_RES >> 1)) / FREQ_RES;   // freq×5 / 4272
```

### 四舍五入技巧:
```verilog
// Verilog整数除法是向下取整
// 10 / 3 = 3 (丢弃余数)

// 实现四舍五入: (a + b/2) / b
// 例: 14.04 → (60000 + 2136) / 4272 = 62136 / 4272 = 14.54 → 14 ✅
//     14.96 → (64000 + 2136) / 4272 = 66136 / 4272 = 15.48 → 15 ✅
```

---

## 📊 修复效果验证

### 理论计算:

#### 20kHz方波:
```
基波频率: 20000 Hz
3次谐波:
  频率: 20000 × 3 = 60000 Hz
  理论bin: 60000 / 4272 = 14.04
  计算: (60000 + 2136) / 4272 = 14.54 → 14
  误差: |14 - 14.04| = 0.04 bin ✅✅

5次谐波:
  频率: 20000 × 5 = 100000 Hz
  理论bin: 100000 / 4272 = 23.41
  计算: (100000 + 2136) / 4272 = 23.91 → 23
  误差: |23 - 23.41| = 0.41 bin ✅✅
```

#### 600kHz方波:
```
3次谐波:
  频率: 600000 × 3 = 1800000 Hz
  理论bin: 421.30
  计算: (1800000 + 2136) / 4272 = 421.85 → 421
  误差: 0.30 bin ✅

5次谐波:
  频率: 3000000 Hz
  理论bin: 702.25
  计算: 702.75 → 702
  误差: 0.25 bin ✅
```

#### 1MHz方波:
```
3次谐波:
  频率: 3000000 Hz
  理论bin: 702.25
  计算: 702
  误差: 0.25 bin ✅

5次谐波:
  频率: 5000000 Hz
  理论bin: 1170.41
  计算: 1170
  误差: 0.41 bin ✅
```

### 结论:
✅ **所有频率的谐波bin误差 < 0.5**  
✅ **20kHz方波的3次和5次谐波精确定位**  
✅ **600kHz和1MHz的谐波定位保持准确**

---

## 🎯 预期效果

| 频率 | 波形 | v9测量 | v10预期 | 理论值 | 改善 |
|------|------|--------|---------|--------|------|
| 20kHz | 方波 | 0.0% | ~45% | 48.3% | ✅ 从失败到准确 |
| 600kHz | 方波 | 53%±3% | 53%±3% | 48.3% | ✅ 保持准确 |
| 1MHz | 方波 | 20%±1% | 20%±1% | 53.3% | ⚠️ 待分析 |
| 500kHz | 正弦波 | 8.0% | 8.0% | <1% | ⚠️ 待分析 |

### 备注:
- **20kHz方波**: 主要问题已解决 ✅
- **1MHz方波**: THD=20%可能是3次谐波幅度不足，需进一步诊断
- **500kHz正弦波**: THD偏高可能是ADC非线性或系统噪声

---

## 🔧 修改文件

### `source/source/signal_parameter_measure.v`

**修改位置**: Line 650-668

**修改前**:
```verilog
harm2_bin <= (fft_peak_bin << 1);                    // 2次谐波 = 基波×2
harm3_bin <= (fft_peak_bin << 1) + fft_peak_bin;     // 3次谐波 = 基波×3
harm4_bin <= (fft_peak_bin << 2);                    // 4次谐波 = 基波×4
harm5_bin <= (fft_peak_bin << 2) + fft_peak_bin;     // 5次谐波 = 基波×5
```

**修改后**:
```verilog
// 【v10修复】精确谐波bin计算：基于频率而非bin整数倍
harm2_bin <= ((fft_freq_hz << 1) + (FREQ_RES >> 1)) / FREQ_RES;  // freq×2 / 4272
harm3_bin <= ((fft_freq_hz * 3) + (FREQ_RES >> 1)) / FREQ_RES;   // freq×3 / 4272
harm4_bin <= ((fft_freq_hz << 2) + (FREQ_RES >> 1)) / FREQ_RES;  // freq×4 / 4272
harm5_bin <= ((fft_freq_hz * 5) + (FREQ_RES >> 1)) / FREQ_RES;   // freq×5 / 4272
```

---

## ⚠️ 潜在问题

### 1. 除法时序
**问题**: Verilog除法可能导致长路径，时序违例  
**解决**: 
- 当前实现在`spectrum_addr==0`时计算，只执行一次
- `fft_freq_hz`最大18位, FREQ_RES=4272(13位), 除法结果13位
- 综合工具会优化为常数除法（除以4272）
- 如果时序违例，可拆分为流水线或使用移位近似

### 2. fft_freq_hz有效性
**前提**: `fft_freq_hz`必须在`spectrum_addr==0`时已经是有效的基波频率  
**验证**: 代码第614行在FFT扫描结束时计算`fft_freq_hz`，下次扫描使用 ✅

### 3. 溢出风险
**计算**: `fft_freq_hz * 5`  
**最大值**: 17.5MHz × 5 = 87.5MHz  
**位宽**: 需要27位 (2^27 = 134MHz)  
**当前**: `fft_freq_hz`可能是18位，乘5后需要21位  
**检查**: 需要确认`fft_freq_hz`的位宽定义

让我检查位宽...
