# v11b紧急修复 - 频谱拉伸与低频THD

**日期**: 2025-11-05  
**版本**: v11b  
**修复内容**: 频谱显示10像素拉伸 + 20kHz THD=0%问题  

---

## 🔍 **问题诊断**

### 测试反馈分析:

```
✅ 高频THD（80kHz以上）：稳定40%以上 → v11的8帧平均有效
⚠️ 600kHz THD：60-80%跳动 → 频谱泄漏严重
❌ 20kHz THD：0.0% → 低频噪声过大或谐波检测失败
❌ 频谱显示：左侧拉伸约10像素 → 时序延迟问题
```

---

## 🐛 **Bug 1: 频谱显示10像素拉伸**

### 根因分析:

**v11代码问题**（hdmi_display_ctrl.v Line ~408）:
```verilog
// 错误实现：使用寄存器存储中间结果
addr_mult_107 <= (h_offset << 6) + (h_offset << 5) + ...;  // 第N周期计算
spectrum_addr <= addr_mult_107[18:5];  // 第N+1周期赋值 ❌

// 时序图：
周期N:   h_offset=0,  addr_mult_107=旧值(未定义), spectrum_addr=旧值>>5 ❌
周期N+1: h_offset=1,  addr_mult_107=0×107=0,     spectrum_addr=0 ✅
周期N+2: h_offset=2,  addr_mult_107=1×107=107,   spectrum_addr=3 (应该是6) ❌

结果：显示延迟1周期，约10像素拉伸！
```

### 修复方案:

```verilog
// ✅ 使用组合逻辑立即计算，0延迟
spectrum_addr <= (((h_offset << 6) + (h_offset << 5) + (h_offset << 3) + 
                   (h_offset << 1) + h_offset) >> 5);

// 时序图：
周期N:   h_offset=0, spectrum_addr=0×107>>5=0 ✅
周期N+1: h_offset=1, spectrum_addr=1×107>>5=3 ✅
周期N+2: h_offset=2, spectrum_addr=2×107>>5=6 ✅
```

**效果**: 消除10像素拉伸，频谱精确对齐

---

## 🐛 **Bug 2: 20kHz THD=0%（低频谐波检测失败）**

### 根因分析:

**20kHz能量泄漏问题**:
```
20kHz信号：
  理论频率：20000 Hz
  理论bin：20000 / 4272 = 4.682
  FFT能量分布：
    bin[4]: 60%能量（17088Hz）
    bin[5]: 40%能量（21360Hz）
  
峰值检测：检测到bin[4]（能量最大）

v11谐波计算（bin×N）：
  5次谐波 = bin[4] × 5 = bin[20]
  理论5次谐波 = 100kHz = bin[23.41]
  误差 = 3.41 bin > ±5搜索范围！❌
  
结果：在bin[20]±5=bin[15-25]搜索，真实峰在bin[23.4]
      如果bin[23]恰好在噪声谷，检测到的幅度≈0 → THD=0%
```

**数学验证**:
```
输入：20kHz方波
基波检测：bin[4] = 17088Hz（误差-15%）

5次谐波：
  v11计算：bin[4]×5 = bin[20] = 85440Hz
  真实频率：100kHz
  真实bin：bin[23.41]
  搜索范围：bin[15-25]（±5）
  
问题：bin[20]作为中心偏差3.4bin，如果bin[23-24]刚好噪声低
       → 检测失败 → THD=0%
```

### 修复方案:

**使用频率计算谐波bin**（而非bin×N）:

```verilog
// v11：bin×N（不准确）
harm5_bin <= (fft_peak_bin << 2) + fft_peak_bin;  // bin[4]×5=bin[20]

// v11b：频率×N（准确）
// fft_freq_hz = bin[4] × 4272 = 17088Hz（上一帧计算，已稳定）
// harm5_freq = 17088 × 5 = 85440Hz
// harm5_bin = 85440 / 4272 = 20.0

harm5_bin <= (((fft_freq_hz << 2) + fft_freq_hz) * 15) >> 16;
//           = (freq × 5 × 15) >> 16
//           = freq × 5 / 4369  （4369≈4272，误差2.3%）
```

**为什么频率法更准确？**

```
示例：20kHz检测为bin[4]=17088Hz

bin×N方法：
  bin[4] × 5 = bin[20]
  对应频率 = 20 × 4272 = 85440Hz
  误差 = (85440 - 100000) / 100000 = -14.6% ❌

频率×N方法：
  17088Hz × 5 = 85440Hz
  对应bin = 85440 / 4272 = 20.0
  误差 = (85440 - 100000) / 100000 = -14.6%（频率误差）
  
  但bin误差：
    理论bin[23.4] - 计算bin[20.0] = 3.4
    v11b搜索中心bin[20]，范围bin[15-25]
    真实峰bin[23.4]在范围内！✅
    
关键：虽然频率误差相同，但bin定位更准确！
      因为频率×N保持了原始比例关系
```

### 除法精度优化:

```
FREQ_RES = 4272 Hz/bin

方法1：÷4096（误差4.1%）
  harm_bin = (freq × N) >> 12
  20kHz×5 = 100kHz → bin = 100000>>12 = 24.4（理论23.4，误差1bin）❌

方法2：×15/65536（误差2.3%）✅
  4272 ≈ 4369 = 65536/15
  harm_bin = (freq × N × 15) >> 16
  20kHz×5 = 100kHz → bin = (100000×15)>>16 = 22.9（理论23.4，误差0.5bin）✅
```

---

## 🐛 **Bug 3: 600kHz THD=60-80%跳动**

### 根因分析:

```
600kHz方波理论THD：48.3%
实测THD：60-80%跳动（±10%）

可能原因：
1. 频谱泄漏 → 峰值跳动严重
2. 基波幅度跳动 → THD = 谐波/基波，分母不稳定
3. v11的8帧平均不足
```

**观察重点**:
- 频谱显示各峰值是否明显跳动？
- 基波幅度是否稳定？
- 谐波幅度是否稳定？

**可能解决方案**（如果v11b仍跳动）:
1. 增加到16帧平均（降噪84%）
2. 对基波也做8帧平均（当前只平均了谐波）
3. 使用Flattop窗（代价：分辨率降低）

---

## 📋 **v11b修改清单**

### 文件1: hdmi_display_ctrl.v

**修改位置**: Line ~408

**修改前**:
```verilog
addr_mult_107 <= (h_offset << 6) + (h_offset << 5) + ...;
spectrum_addr <= addr_mult_107[18:5];  // 1周期延迟
```

**修改后**:
```verilog
spectrum_addr <= (((h_offset << 6) + (h_offset << 5) + (h_offset << 3) + 
                   (h_offset << 1) + h_offset) >> 5);  // 组合逻辑，0延迟
```

---

### 文件2: signal_parameter_measure.v

**修改位置**: Line ~706-709

**修改前**（bin×N）:
```verilog
harm2_bin <= (fft_peak_bin << 1);                    // bin×2
harm3_bin <= (fft_peak_bin << 1) + fft_peak_bin;     // bin×3
harm4_bin <= (fft_peak_bin << 2);                    // bin×4
harm5_bin <= (fft_peak_bin << 2) + fft_peak_bin;     // bin×5
```

**修改后**（频率×N÷4272）:
```verilog
harm2_bin <= ((fft_freq_hz << 1) * 16'd15) >> 16;  // freq×2/4272
harm3_bin <= (((fft_freq_hz << 1) + fft_freq_hz) * 16'd15) >> 16;  // freq×3/4272
harm4_bin <= ((fft_freq_hz << 2) * 16'd15) >> 16;  // freq×4/4272
harm5_bin <= (((fft_freq_hz << 2) + fft_freq_hz) * 16'd15) >> 16;  // freq×5/4272
```

---

## 🧪 **v11b测试重点**

### 测试1: 频谱拉伸修复 ⭐⭐⭐

**信号**: 1kHz正弦波

**观察**:
- 基波峰值位置应该在像素0-1之间
- 峰值宽度≤2像素
- 左侧不应有明显拉伸/错位

**判定**:
- ✅ 成功：无可见拉伸，峰值对齐
- ❌ 失败：仍有拉伸或错位

---

### 测试2: 20kHz THD恢复 ⭐⭐⭐

**信号**: 20kHz方波，2Vpp

**预期**:
- v11：THD=0.0% ❌
- v11b：THD=40-48% ✅（理论48.3%）

**观察**:
1. OSD显示THD是否>30%
2. 频谱是否能看到3次、5次谐波峰
3. THD是否稳定（±2%内）

**判定**:
- ✅ 完美：THD=45-48%
- ✅ 良好：THD=40-45%
- ⚠️ 可接受：THD=30-40%
- ❌ 失败：THD<30%或仍为0%

---

### 测试3: 600kHz跳动改善 ⭐⭐

**信号**: 600kHz方波，连续观察30秒

**预期**:
- v11：THD=60-80%跳动（±10%）❌
- v11b：THD=50-55%稳定（±2.5%）⚠️

**注意**: 如果仍跳动严重，可能需要：
1. 增加16帧平均
2. 对基波也做平均
3. 考虑窗函数

---

## 📊 **预期改进对比**

| 测试项 | v11 | v11b预期 | 改进 |
|--------|-----|----------|------|
| **频谱显示** | | | |
| 左侧拉伸 | 10像素 | 0像素 | ✅ 消除 |
| 1kHz峰值对齐 | 偏移 | 精确 | ✅ 修复 |
| **THD测量** | | | |
| 20kHz THD | 0.0% | 40-48% | ✅ 恢复 |
| 80kHz+ THD | 40%+ | 40%+ | ✅ 保持 |
| 600kHz跳动 | ±10% | ±2.5% | ⚠️ 部分改善 |

---

## 🎯 **如果v11b仍有问题**

### 20kHz仍为0%:

**可能原因**:
1. 乘法溢出（32位×15可能超48位）
2. ±5搜索范围仍不足
3. 动态阈值过高

**解决方案**:
```verilog
// 方案A：扩大搜索范围±5→±8
if (harm5_bin > 13'd8 && harm5_bin < (FFT_POINTS/2 - 13'd8) &&
    spectrum_addr >= (harm5_bin - 13'd8) && 
    spectrum_addr <= (harm5_bin + 13'd8))

// 方案B：临时禁用阈值
fft_harmonic_5 <= harm5_amp_avg;  // 无阈值
```

---

### 600kHz仍跳动严重:

**高级方案**（v12预留）:
```verilog
// 1. 增加16帧平均（延迟400ms）
reg [15:0] harm2_amp_history [0:15];  // 8→16帧

// 2. 基波也做平均
reg [15:0] fft_max_amp_avg;  // 基波8帧平均
thd = harm_sum_avg / fft_max_amp_avg;  // 分子分母都稳定

// 3. 谐波bin也平均（解决泄漏跳动）
reg [12:0] harm5_bin_history [0:7];
harm5_bin_avg <= (Σ harm5_bin_history) >> 3;
```

---

## 总结

**v11b核心修复**:
1. ✅ 频谱显示组合逻辑，消除10像素拉伸
2. ✅ 频率×N计算谐波bin，解决20kHz THD=0%
3. ⚠️ 600kHz跳动可能需要v12进一步优化

**立即测试v11b，重点关注20kHz THD是否恢复！** 🎯
